##** 1. O Conceito de Fila (FIFO)**

Imagine uma fila de banco: a primeira pessoa que chega é a primeira a ser atendida. Novos elementos entram pelo fim da fila e saem pelo início.
Diagrama de Operações:

      ENTRADA (Enqueue)             SAÍDA (Dequeue)
             │                             ▲
             ▼                             │
       ┌───────────┐                 ┌───────────┐
 Fim ──┤  Item 3   │           Fim ──┤  Item 3   │
       ├───────────┤                 ├───────────┤
       │  Item 2   │                 │  Item 2   │
       ├───────────┤                 ├───────────┤
Início ┤  Item 1   │           Início ┤  Item 1   │ (Removido)
       └───────────┘                 └───────────┘

2. Implementação em JavaScript: Queue.js

Utilizaremos uma estrutura de objeto para garantir que tanto a entrada quanto a saída tenham 
performance constante O(1).

javascript


# Classe que representa uma Fila (Queue)

class Queue {
  constructor() {
    this.count = 0;          // Rastreador da posição do próximo item (Fim)
    this.lowestCount = 0;    // Rastreador do primeiro item (Início)
    this.items = {};         // Armazenamento
  }

  // Adiciona um elemento ao final da fila (Enqueue)
  enqueue(element) {
    this.items[this.count] = element; // Adiciona no final
    this.count++; // Move o ponteiro do fim para a próxima vaga
  }

  // Remove e retorna o primeiro elemento da fila (Dequeue)
  dequeue() {
    if (this.isEmpty()) return undefined;

    const result = this.items[this.lowestCount]; // Guarda o primeiro item
    delete this.items[this.lowestCount];         // Remove da memória
    this.lowestCount++;                          // Move o ponteiro do início para o próximo
    return result;
  }

  // Apenas visualiza o primeiro elemento (Peek)
  peek() {
    if (this.isEmpty()) return undefined;
    return this.items[this.lowestCount];
  }

  isEmpty() {
    // A fila está vazia se a diferença entre fim e início for zero
    return this.count - this.lowestCount === 0;
  }

  size() {
    return this.count - this.lowestCount;
  }

  clear() {
    this.items = {};
    this.count = 0;
    this.lowestCount = 0;
  }

  // Formata para [ item1 item2 ]
  toString() {
    if (this.isEmpty()) return '[]';
    
    let values = [];
    for (let i = this.lowestCount; i < this.count; i++) {
      values.push(this.items[i]);
    }
    return `[ ${values.join(" ")} ]`;
  }
}

export default Queue;
Use o código com cuidado.

# 3. Teste Manual: testaFila.js

javascript

import Queue from './Queue.js';

const fila = new Queue();

console.log("Inserindo: A, B, C");
fila.enqueue("A");
fila.enqueue("B");
fila.enqueue("C");

console.log("Fila atual:", fila.toString()); // [ A B C ]
console.log("Primeiro da fila (Peek):", fila.peek()); // A

console.log("Atendendo (Dequeue):", fila.dequeue()); // A
console.log("Fila após atendimento:", fila.toString()); // [ B C ]

console.log("Tamanho atual:", fila.size()); // 2
Use o código com cuidado.

# 4. Detalhes Importantes para 2025

Por que lowestCount?: Em uma fila, quando removemos o primeiro item, não queremos "re-indexar" 
todos os outros itens (isso seria lento, O(n)). Usamos o lowestCount para simplesmente "pular" o ponteiro do início para frente.

Performance O(1): Graças ao uso de objetos e ponteiros numéricos, tanto inserir (enqueue) quanto remover (dequeue) são operações instantâneas, não importa se a fila tem 10 ou 1 milhão de itens [1].

Memória: O comando delete é crucial para evitar memory leaks, garantindo que os itens removidos sejam coletados pelo Garbage Collector do Node.js [2].

# Resumo Big O

 - Inserção (Enqueue): O(1)

 - Remoção (Dequeue): O(1)

 - Acesso ao Início (Peek): O(1)

 - Para rodar este código no seu terminal:

bash

 node testaFila.js

//////////////////////////////////////////////////////////////////////////////////


Em uma implementação comum de fila (queue) em JavaScript usando um objeto para armazenamento, 
this.count e this.lowestCount têm finalidades distintas e trabalham em conjunto para gerenciar os elementos de forma eficiente: 

 - this.count: Rastreia o número total de elementos que foram adicionados à fila ao longo do tempo (o índice do próximo elemento a ser inserido, essencialmente o final da fila, ou "rear"). Ele é incrementado a cada operação de enqueue (adicionar).

 - this.lowestCount: Rastreia o índice do primeiro elemento na fila que ainda não foi removido (o início da fila, ou "front"). 

Como eles funcionam juntos

A chave para entender a diferença é como os elementos são removidos em uma fila (operação dequeue).
enqueue: Quando um elemento é adicionado, ele é colocado na posição this.count, e this.count é incrementado.

javascript

enqueue(element) {
    this.items[this.count] = element;
    this.count++;
}
dequeue: Quando um elemento é removido, ele é retirado da posição this.lowestCount, e this.lowestCount é incrementado para apontar para o novo primeiro elemento.

javascript

dequeue() {
    if (this.isEmpty()) {
        return undefined;
    }
    const result = this.items[this.lowestCount];
    delete this.items[this.lowestCount]; // Opcional, mas recomendado para liberar memória
    this.lowestCount++;
    return result;
}
 
Diferença Prática

A principal diferença é que this.count continua a aumentar com cada adição, enquanto this.lowestCount aumenta com cada remoção do início. O número real de elementos na fila a qualquer momento é calculado pela diferença entre eles: this.count - this.lowestCount. 
Essa abordagem, que usa um objeto (this.items) em vez de um array para armazenar os elementos e mantém esses dois ponteiros de índice, permite que as operações de enqueue e dequeue tenham uma complexidade de tempo constante O(1), o que é mais eficiente do que usar métodos de array como shift(), que podem ter complexidade O(n). 

//////////////////////////////////////////////////////////////////////////////////////////

Fila (Queue) em um cenário real: um Simulador de Fila de Impressão.

Neste exemplo, cada "item" da fila será um documento enviado para uma impressora. O primeiro documento enviado deve ser o primeiro a ser impresso.

Implementação Prática: FilaImpressao.js

/**
 * Classe que representa a estrutura de dados Fila
 */
class Queue {
  constructor() {
    this.count = 0;          // Monitora o final da fila (onde novos itens entram)
    this.lowestCount = 0;    // Monitora o início da fila (de onde itens saem)
    this.items = {};         // Objeto que armazena os elementos
  }

  // Adiciona um documento para o final da fila
  enqueue(element) {
    this.items[this.count] = element; // Adiciona o documento no índice atual do fim
    this.count++;                     // Prepara a próxima posição do fim
  }

  // Remove e retorna o documento do início (o que será impresso)
  dequeue() {
    if (this.isEmpty()) return undefined; // Se não houver documentos, retorna nada

    const result = this.items[this.lowestCount]; // Armazena o documento do início
    delete this.items[this.lowestCount];         // Remove o documento processado da memória
    this.lowestCount++;                          // Move o ponteiro do início para o próximo documento
    return result;                               // Retorna o documento que foi "impresso"
  }

  // Apenas espia qual é o próximo documento na vez
  peek() {
    if (this.isEmpty()) return undefined;
    return this.items[this.lowestCount];
  }

  // Verifica se ainda existem documentos na fila
  isEmpty() {
    return this.count - this.lowestCount === 0;
  }

  // Retorna a quantidade de documentos aguardando
  size() {
    return this.count - this.lowestCount;
  }

  // Formata a fila para exibição visual: [ doc1 doc2 ]
  toString() {
    if (this.isEmpty()) return '[]';
    let values = [];
    for (let i = this.lowestCount; i < this.count; i++) {
      values.push(this.items[i]);
    }
    return `[ ${values.join(" ")} ]`;
  }
}

// --- EXEMPLO PRÁTICO: SIMULADOR DE IMPRESSORA ---

const impressoraHP = new Queue(); // Instancia nossa fila de impressão

console.log("--- Enviando documentos para a impressora ---");
impressoraHP.enqueue("Relatorio_Financeiro.pdf");
impressoraHP.enqueue("Foto_Ferias.jpg");
impressoraHP.enqueue("Contrato_Aluguel.docx");

console.log("Documentos na fila:", impressoraHP.toString()); 
// Saída: [ Relatorio_Financeiro.pdf Foto_Ferias.jpg Contrato_Aluguel.docx ]

console.log("\nQual o próximo documento da vez?", impressoraHP.peek());
// Saída: Relatorio_Financeiro.pdf

console.log("\n--- Iniciando impressões ---");
console.log("Imprimindo agora:", impressoraHP.dequeue()); // Imprime o Financeiro
console.log("Imprimindo agora:", impressoraHP.dequeue()); // Imprime a Foto

console.log("\nQuantos documentos restam?", impressoraHP.size()); 
// Saída: 1

console.log("Fila atualizada:", impressoraHP.toString());
// Saída: [ Contrato_Aluguel.docx ]


////////////////////////////////////////////////////////////////////////

Explicação da Lógica Passo a Passo:

this.count vs this.lowestCount: Em 2025, esta é a técnica padrão para filas eficientes. Em vez de mover todos os itens de lugar (o que seria lento), apenas movemos o ponteiro do início (lowestCount) para frente.
delete: 

O uso do operador delete é fundamental para evitar o acúmulo de dados desnecessários no objeto items, liberando memória conforme os documentos são "impressos".

Encapsulamento: A classe esconde a complexidade de gerenciar índices, oferecendo métodos simples como enqueue e dequeue.

Por que usar este exemplo no seu Ebook?

Este exemplo demonstra o conceito FIFO (First In, First Out) de forma tangível. É fácil para o leitor entender que em uma impressora, quem envia o arquivo primeiro, recebe a impressão primeiro.

Dica de Execução:

Para rodar este código, salve-o como FilaImpressao.js e execute no terminal do VS Code:

bash

node FilaImpressao.js


Para aprofundar em casos de uso de filas em servidores modernos, consulte a Documentação de Filas do Node.js [1].

 - Na Pilha (Stack): Você só se preocupa com o fim do objeto (o topo).

 - Na Fila (Queue): Você precisa de dois ponteiros (um para o início e outro para o fim), pois ela 
 cresce de um lado e diminui do outro.

 - Na Lista Encadeada (LinkedList): Você não usa um objeto simples ou array para guardar tudo; você
  usa Nós (Nodes) que se conectam por referências.

 - Na Árvore (Tree): A estrutura é hierárquica (esquerda/direita), mudando completamente como os 
 dados são organizados na memória.

The End
///////////////////////////////////////////////////////////////////////////////////////////////